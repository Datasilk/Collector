using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Net;
using Collector.Common.DOM;
using Collector.Common.Models.Articles;
using Collector.Common.Models.DOM;
using Collector.Common.Extensions.Strings;

namespace Collector.Common
{
    public static class Html
    {
        #region "Step #1: Get HTML Document"
        /// <summary>
        /// An object mapper that converts the JSON representation of a fully rendered HTML web page into a C# object
        /// </summary>
        /// <param name="dom">The JSON object generated by Charlotte (https://github.com/Datasilk/Charlotte)</param>
        /// <returns>A hiarachal list of DOM elements</returns>
        /// <exception cref="Exception"></exception>
        public static AnalyzedArticle DeserializeArticle(string dom)
        {
            var article = new AnalyzedArticle();
            try
            {
                //deserialize object from string
                var node = JsonSerializer.Deserialize<Document>(dom, new JsonSerializerOptions()
                {
                    MaxDepth = 256
                });
                var html = new StringBuilder();
                var hierarchy = new List<int>();
                var parser = new Parser("");
                var dict = new Dictionaries() { t = node.t, a = node.a, cn = node.cn };

                //build DOM tree
                var elems = new List<DomElement>();
                var index = 0;
                Traverse(node.dom, ref index, elems, hierarchy, dict, parser);
                parser.Elements = elems;
                article.elements = elems;
                article.rawHtml = FormatHtml(elems).ToString();
                article.url = node.url;
            }
            catch (Exception ex)
            {
                article.rawHtml = dom;
                throw new Exception();
            }


            return article;
        }

        private static DomElement Traverse(Node parent, ref int index, List<DomElement> elems, List<int> hierarchy, Dictionaries dict, Parser parser)
        {
            //create local copy of hierarchy
            var parentId = -1;
            int[] hier = new int[hierarchy.Count];
            if (hierarchy.Count > 0)
            {
                hierarchy.CopyTo(hier);
                parentId = hierarchy[hierarchy.Count() - 1];
            }

            //create DOM element
            var elem = new DomElement(parser);
            elem.index = index;
            elem.parent = parentId;
            elem.tagName = dict.t[parent.t];
            elem.className = parent.n != null && parent.n.Length > 0 ? parent.n.Select(a => dict.cn[a]).ToList() : new List<string>();
            elem.hierarchyIndexes = hier.ToArray();
            elem.childIndexes = new List<int>();
            elem.style = new Dictionary<string, string>();
            elem.attribute = new Dictionary<string, string>();

            switch (elem.tagName)
            {
                case "#text":
                case "br":
                case "meta":
                case "link":
                case "hr":
                case "img":
                    elem.isSelfClosing = true;
                    break;
            }

            if (elem.tagName == "#text")
            {
                elem.text = parent.v;
            }

            //build style list for element
            if (parent.s != null)
            {
                switch (parent.s[0])
                {
                    case 0: elem.style.Add("display", "none"); break;
                    case 2: elem.style.Add("display", "inline"); break;
                    case 3: elem.style.Add("display", "inline-block"); break;
                }
                elem.style.Add("font-size", parent.s[1].ToString() + "px");
                if (parent.s[2] == 2)
                {
                    elem.style.Add("font-weight", "bold");
                }
                if (parent.s[3] == 1)
                {
                    elem.style.Add("font-style", "italic");
                }
            }

            //build attributes list
            if (parent.a != null)
            {
                foreach (var x in parent.a)
                {
                    if (dict.a[x.Key] == "class")
                    {
                        elem.className = x.Value.Replace("  ", " ").Replace("  ", " ").Split(" ").ToList();
                    }
                    else
                    {
                        elem.attribute.Add(dict.a[x.Key], x.Value);
                    }
                }
            }

            //append index to hierarchy list
            hier = hier.Append(index).ToArray();

            //add element to DOM elements list
            elems.Add(elem);

            if (parent.c != null)
            {
                //traverse all children
                foreach (var child in parent.c)
                {
                    index++;
                    var childElem = Traverse(child, ref index, elems, hier.ToList(), dict, parser);
                    elem.childIndexes.Add(childElem.index);
                }
            }

            if (elem.isSelfClosing == false)
            {
                //add closing tag to DOM elements list
                index++;
                var closing = new DomElement(parser);
                closing.index = index;
                closing.tagName = "/" + dict.t[parent.t];
                closing.hierarchyIndexes = hierarchy.ToArray();
                closing.childIndexes = new List<int>();
                closing.style = new Dictionary<string, string>();
                closing.attribute = new Dictionary<string, string>();
                closing.isClosing = true;
                elems.Add(closing);
            }
            return elem;
        }

        public static StringBuilder FormatHtml(List<DomElement> elements)
        {
            var htms = new StringBuilder();
            var htmelem = "";
            var tabs = "";
            foreach (var el in elements)
            {
                tabs = "";
                if (el.isClosing == true && el.isSelfClosing == false)
                {
                    //closing tag
                    htmelem = "<" + el.tagName + ">";
                }
                else
                {
                    if (el.tagName == "#text")
                    {
                        htmelem = el.text;
                    }
                    else
                    {
                        htmelem = "<" + el.tagName;
                        if (el.className.Count() > 0)
                        {
                            htmelem += " class=\"" + string.Join(" ", el.className) + "\"";
                        }
                        if (el.attribute != null)
                        {
                            if (el.attribute.Count > 0)
                            {
                                foreach (var attr in el.attribute)
                                {
                                    htmelem += " " + attr.Key + "=\"" + attr.Value + "\"";
                                }
                            }
                        }

                        if (el.isSelfClosing == true)
                        {
                            if (el.tagName == "!--")
                            {
                                htmelem += el.text + "-->";
                            }
                            else
                            {
                                htmelem += "/>";
                            }

                        }
                        else
                        {
                            htmelem += ">" + el.text;
                        }
                    }


                }

                for (var x = 0; x < el.hierarchyIndexes.Length - 1; x++)
                {
                    tabs += "    ";
                }
                htms.Append(tabs + htmelem + "\n");
            }
            return htms;
        }

        private static Char[] attrKeywords = new Char[] { '=', '*', '~', '^', '$' };

        public class Nth
        {
            public string operatorType { get; set; }
            public string input1Type { get; set; }
            public int input1Value { get; set; }
            public string input2Type { get; set; }
            public int input2Value { get; set; }
        }

        /// <summary>
        /// Use a CSS selector to find HTML elements within the DOM
        /// </summary>
        /// <param name="selector">CSS selector</param>
        /// <param name="elems">A list of DOM elements to search through</param>
        /// <returns></returns>
        public static List<DomElement> FindElements(string selector, List<DomElement> elems, List<DomElement> dom)
        {

            var attrFlag = false;
            var part = "";
            var part2 = "";
            for (var x = 0; x < selector.Length; x++)
            {
                if (attrFlag == true)
                {
                    if (selector[x] == ']')
                    {
                        attrFlag = false;
                    }
                    continue;
                }
                if (selector[x] == '[')
                {
                    attrFlag = true;
                }
                else if (selector[x] == ' ')
                {
                    part = selector.Substring(0, x);
                    part2 = selector.Substring(x + 1);
                    break;
                }
            }
            if (part == "")
            {
                part = selector;
            }

            if (part == "*")
            {
                return elems;
            }

            //find all element indexes for each part of the selector ////////////////////////
            var newElems = elems;

            //find colon
            var colon = part.IndexOf(':');
            var afterColon = "";
            if (colon > -1)
            {
                var parts = part.Split(':', 2);
                part = parts[0];
                afterColon = parts[1];
            }
            //find attributes
            var attrIndex = part.IndexOf('[');
            var attrs = new List<string>();
            while (attrIndex > -1)
            {
                var parts2 = part.Split('[');
                var bracket = parts2[1].IndexOf("]");
                if (bracket > 0)
                {
                    var attr = parts2[1].Substring(0, bracket);
                    attrs.Add(attr);
                    part = part.Replace(attr, "");
                }
                else
                {
                    part = parts2[0];
                }
                attrIndex = part.IndexOf('[');
            }

            //find element identifiers (classes, ids, tagnames)
            if (part != "" && part[0] != '*')
            {
                var partIds = new List<string>();
                var startIndex = 0;
                while (startIndex >= 0)
                {
                    var nextIndex = part.IndexOf('.', startIndex + 1);
                    if (nextIndex == -1)
                    {
                        nextIndex = part.IndexOf("#", startIndex + 1);
                    }
                    if (nextIndex == -1)
                    {
                        partIds.Add(part.Substring(startIndex));
                    }
                    else
                    {
                        partIds.Add(part.Substring(startIndex, nextIndex - startIndex));
                    }
                    startIndex = nextIndex;
                }

                for (var x = 0; x < partIds.Count; x++)
                {
                    var partId = partIds[x];

                    //narrow list by all part ids
                    if (partId[0] == '.')
                    {
                        //class name
                        var name = partId.Substring(1);
                        newElems = newElems.Where(a => a.className != null && a.className.Contains(name)).ToList();

                    }
                    else if (partId[0] == '#')
                    {
                        //id attribute
                        var id = partId.Substring(1);
                        newElems = newElems.Where(a => a.attribute.ContainsKey("id") && a.attribute["id"] == id).ToList();
                    }
                    else
                    {
                        //tag name
                        //id attribute
                        var tag = partId;
                        newElems = newElems.Where(a => a.tagName == tag).ToList();
                    }
                }
            }

            //narrow results by attributes
            foreach (var attr in attrs)
            {
                var attrName = "";
                var attrKey = "";
                var attrValue = "";
                for (var x = 0; x < attr.Length; x++)
                {
                    if (attrKeywords.Any(a => a == attr[x]))
                    {
                        attrName = attr.Substring(0, x).Trim();
                        attrKey = attr.Substring(x, 1);
                        if (attr.Substring(x + 1, 1) == "=")
                        {
                            attrKey = attr.Substring(x, 2);
                            attrValue = attr.Substring(x + 2).Trim();
                        }
                        else
                        {
                            attrValue = attr.Substring(x + 1).Trim();
                        }
                        break;
                    }
                }
                if (attrName == "") { attrName = attr; }
                ;

                if (attrName != "" && attrValue != "")
                {
                    attrValue = attrValue.Replace("\"", "");

                    //narrow list based on attribute
                    if (attrName == "#text")
                    {
                        newElems = newElems.Where(a => {
                            if (a.childIndexes.Count > 0)
                            {
                                var txt = Html.GetTextFromElement(a, 1);
                                if (txt.Count > 0)
                                {
                                    var t = string.Join(" ", txt.Select(a => a.Trim()));
                                    switch (attrKey)
                                    {
                                        case "=":
                                            return t == attrValue;
                                        case "^=":
                                            return t.IndexOf(attrValue) == 0;
                                        case "$=":
                                            return t.IndexOf(attrValue) == t.Length - attrValue.Length - 1;
                                        case "*=":
                                            if (t.IndexOf(attrValue) >= 0)
                                            {

                                            }
                                            return t.IndexOf(attrValue) >= 0;
                                    }
                                }
                            }
                            return false;
                        }).ToList();
                    }
                }
                else if (attrName != "")
                {
                    //see if attribute exists
                    newElems = newElems.Where(a => a.attribute != null && a.attribute.ContainsKey(attrName)).ToList();
                }
            }

            //check for colon keywords
            if (afterColon != "")
            {
                var cols = afterColon.Split('(');
                var param = cols.Length > 1 ? cols[1].Substring(0, cols[1].Length - 1) : "";
                switch (cols[0].Trim())
                {
                    case "nth-child":
                        var nthElements = new List<DomElement>();
                        var nthChar = 0;
                        var num = "";
                        var Nth = new Nth();
                        var Nths = new List<Nth>();
                        DomElement el;
                        while (nthChar > -1)
                        {
                            var c = param[nthChar];
                            if (c.Asc() >= 48 && c.Asc() <= 57)
                            {
                                //found number
                                num += c;
                            }
                            else
                            {
                                //not number
                                if (num != "")
                                {
                                    if (Nth.input1Type == "")
                                    {
                                        //add existing number to input #1
                                        Nth.input1Type = "#";
                                        Nth.input1Value = int.Parse(num);
                                    }
                                    else if (Nth.input2Type == "")
                                    {
                                        //add existing number to input #2
                                        Nth.input2Type = "#";
                                        Nth.input2Value = int.Parse(num);
                                        Nths.Add(Nth);
                                        Nth = new Nth();
                                    }
                                    num = "";
                                }
                                if (c == 'n')
                                {
                                    //found Nth
                                    var type = "n";
                                    if (nthChar > 0 && param[nthChar - 1] == '-')
                                    {
                                        //negative
                                        type = "-n";
                                    }
                                    if (Nth.input1Type == "")
                                    {
                                        //add Nth to input #1
                                        Nth.input1Type = type;
                                    }
                                    else if (Nth.input2Type == "")
                                    {
                                        //add Nth to input #2
                                        Nth.input2Type = type;
                                        Nths.Add(Nth);
                                        Nth = new Nth();
                                    }
                                }
                            }
                        }
                        for (var x = 0; x < newElems.Count; x++)
                        {

                        }

                        break;
                    case "parent":
                        var depth = 0;
                        int.TryParse(param, out depth);
                        if (depth < 0) { depth = 1; }
                        newElems = newElems.Select(a => {
                            var p = a;
                            for (var x = 1; x <= depth; x++)
                            {
                                p = p.Parent;
                            }
                            return p;
                        }).Where(a => a != null).Distinct().ToList();
                        break;
                    case "has-parent":
                        newElems = newElems.Where(a =>
                        {
                            var parent = a.Parent;
                            var parents = new List<DomElement>();
                            while (parent != null)
                            {
                                parents.Add(parent);
                                parent = parent.Parent;
                            }
                            if (parents.Count > 0)
                            {
                                return FindElements(param, parents, dom).Count > 0;
                            }
                            else
                            {
                                return false;
                            }
                        }).ToList();
                        break;
                    case "no-parent-or-child":
                        newElems = newElems.Where(a =>
                        {
                            var parent = a.Parent;
                            var parents = new List<DomElement>() { a };
                            while (parent != null)
                            {
                                parents.Add(parent);
                                parent = parent.Parent;
                            }
                            parents.AddRange(a.AllChildren());
                            if (parents.Count > 0)
                            {
                                return FindElements(param, parents, dom).Count == 0;
                            }
                            else
                            {
                                return true;
                            }
                        }).ToList();
                        break;
                    case "no-child":
                        newElems = newElems.Where(a =>
                        {
                            var children = a.AllChildren();
                            if (children.Count > 0)
                            {
                                return FindElements(param, children, dom).Count == 0;
                            }
                            else
                            {
                                return true;
                            }
                        }).ToList();
                        break;
                    case "first":
                        el = newElems.FirstOrDefault();
                        newElems = new List<DomElement>();
                        if (el != null) { newElems.Add(el); }
                        break;
                    case "not-first":
                        el = newElems.FirstOrDefault();
                        newElems = newElems.Where(a => a != el).ToList();
                        break;
                }
            }

            //narrow results by keyword after colon
            if (part2 != "")
            {
                var nextpart = part2.Split(' ')[0];
                var children = new List<DomElement>();
                if (nextpart == ">")
                {
                    foreach (var elem in newElems)
                    {
                        TraverseElements(elem, children, 1);
                    }
                    part2 = part2.Substring(2);
                }
                if (nextpart == "+")
                {
                    foreach (var elem in newElems)
                    {
                        var el = elem.NextSibling;
                        if (el != null) { children.Add(el); }
                    }
                    part2 = part2.Substring(2);
                }
                if (nextpart == "~")
                {
                    foreach (var elem in newElems)
                    {
                        var el = elem.NextSibling;
                        while (el != null)
                        {
                            children.Add(el);
                            el = el.NextSibling;
                        }
                    }
                    part2 = part2.Substring(2);
                }
                else
                {
                    foreach (var elem in newElems)
                    {
                        TraverseElements(elem, children);
                    }
                }
                newElems = FindElements(part2, children, dom);
            }
            return newElems;
        }

        public static int TraverseElements(DomElement root, List<DomElement> children, int limitDepth = -1)
        {
            var childNodes = root.Children();
            var maxDepth = 1;
            for (var x = 0; x < childNodes.Count; x++)
            {
                children.Add(childNodes[x]);
                if (limitDepth != 0)
                {
                    var depth = TraverseElements(childNodes[x], children, limitDepth -= 1);
                    if (depth > maxDepth) { maxDepth = depth; }
                }
            }
            return maxDepth;
        }
        #endregion

        #region "Step #2: Get Article Info"
        public static void GetArticleInfoFromDOM(AnalyzedArticle article)
        {
            //get title
            article.title = "";
            var title = article.elements.Where(a => a.tagName == "title").FirstOrDefault();
            if (title != null)
            {
                var child = title.FirstChild;
                if (child != null)
                {
                    article.title = child.text;
                }
            }
            if (article.title == "")
            {
                //get title from header tags
                var headers = article.elements.Where(a =>
                {
                    switch (a.tagName)
                    {
                        case "h1":
                        case "h2":
                        case "h3":
                        case "h4":
                        case "h5":
                        case "h6":
                            return true;
                    }
                    return false;
                }).OrderBy(a => a.tagName).ToList();
                if (headers.Count > 0)
                {
                    for (var x = 0; x < headers.Count; x++)
                    {
                        var child = headers[x].FirstChild;
                        if (child != null)
                        {
                            if (child.text != "")
                            {
                                article.title = child.text;
                                break;
                            }
                        }
                    }
                }
            }
            if (article.title == "")
            {
                //try getting title from URL path if all else fails
                var path = WebUtility.UrlDecode(article.url.Split("?")[0].Split("#")[0]);
                path = path.Substring(path.IndexOf(article.domain) + article.domain.Length);
                if (path.Length > 0 && path.Substring(0, 1) == "/") { path = path.Substring(1); }
                var ext = path.GetFileExtension();
                var filename = path.GetFilename();
                if (ext != "" && filename.Length > 0)
                {
                    path = path.Replace(filename, "");
                }
                var paths = path.ReplaceAll(" ", new string[] { ":", ";", "-", "_", "+", "=", ",", "  ", "  " }).Split("/").Select(a => a.Trim());
                article.title = string.Join(" ", paths);
            }

            //get page description
            var description = article.elements.Where(a => a.tagName == "meta" && (
                (a.attribute.ContainsKey("name") && a.attribute["name"].ToLower().IndexOf("description") >= 0) ||
                (a.attribute.ContainsKey("property") && a.attribute["property"].ToLower().IndexOf("og:description") >= 0)
                )).FirstOrDefault();
            if (description != null && description.attribute.ContainsKey("content"))
            {
                article.summary = description.attribute["content"];
            }
            article.summary = article.summary.Replace("&mdash;", " ").Replace("&mdash", " ");
        }
        #endregion

        #region "Step #3: Get Article Contents"
        public static int TraverseIndexes(AnalyzedArticle article, DomElement root, List<int> children, int limitDepth = -1)
        {
            var childNodes = root.Children();
            var maxDepth = 1;
            for (var x = 0; x < childNodes.Count; x++)
            {
                children.Add(childNodes[x].index);
                if (limitDepth != 0)
                {
                    var depth = TraverseIndexes(article, childNodes[x], children, limitDepth -= 1);
                    if (depth > maxDepth) { maxDepth = depth; }
                }
            }
            return maxDepth;
        }

        public static void GetBestElementIndexes(AnalyzedArticle article, List<AnalyzedElement> indexes)
        {
            //First, analyze each DOM element /////////////////////////////////////////////////////////////////////
            var futureElements = new List<AnalyzedElement>();

            for (var x = 0; x < article.elements.Count; x++)
            {
                var element = article.elements[x];

                //check if element should be skipped
                if (Rules.skipTags.Contains(element.tagName)) { continue; }

                //initialize analyzed element object
                var index = new AnalyzedElement()
                {
                    Element = element,
                    index = element.index,
                    depth = element.hierarchyIndexes.Length
                };

                //check if any future element exist to replace the new index object with
                if (futureElements.Count > 0 && futureElements.Any(a => a.index == element.index))
                {
                    //clone element and remove from future elements list
                    futureElements.First(a => a.index == element.index).CopyTo(index);
                    futureElements.RemoveAt(futureElements.FindIndex(a => a.index == element.index));
                }

                //build hierarchy of analyzed elements
                foreach (var i in element.hierarchyIndexes)
                {
                    var parent = indexes.FirstOrDefault(a => a.index == i);
                    if (parent != null)
                    {
                        index.hierarchy.Add(parent);
                        if (parent.isContaminated == true) { break; }
                    }
                }
                //check if element is a child of a contaminated parent element
                if (index.hierarchy.Any(a => a.isContaminated == true)) { continue; }

                //check element tag for contamination
                if (element.tagName == "#text")
                {
                    //text element
                    var txt = element.text.ToLower();
                    var words = SeparateWordsFromText(txt);
                    index.UpdateCounter(ElementFlagCounters.words, words.Length);
                    foreach (var elem in index.hierarchy)
                    {
                        //add current element words to all analyzed elements in hierarchy
                        elem.wordsInHierarchy += words.Length;
                    }

                    if (words.Length < 7)
                    {
                        //check if element is potential menu item
                        if (index.hierarchy.Where(a => Rules.textTags.Contains(a.Element.tagName)).Count() == 0 &&
                            index.hierarchy.Where(a => Rules.menuTags.Contains(a.Element.tagName)).Count() > 0 &&
                            CountWordsInText(txt, Rules.badMenu, false) > 0
                        )
                        {
                            index.AddFlag(ElementFlags.MenuItem);
                        }

                        //check if element has an anchor link in the hierarchy
                        if (index.hierarchy.Any(a => a.Element.tagName == "a"))
                        {
                            if (CountWordsInText(txt, Rules.badLinkWords, false) > 0)
                            {
                                index.AddFlag(ElementFlags.BadLinkWord);
                                index.isBad = true;
                            }
                        }

                        //check if element has a header tag (h1, h2, h3, h4, h5, h6) in the hierarchy
                        if (Rules.headerTags.Any(a => index.hierarchy.Any(b => b.Element.tagName == a)))
                        {
                            if (index.isBad == true || Rules.badHeaderWords.Any(a => txt.IndexOf(a) >= 0))
                            {
                                index.AddFlag(ElementFlags.BadHeaderWord);
                                index.isBad = true;

                                //remove ul if exists right below bad header tag
                                var h = index.hierarchy.FindLast(a => Rules.headerTags.Any(b => a.Element.tagName == b));
                                if (h != null)
                                {
                                    var next = h.Element.NextSibling;
                                    if (next != null && next.tagName == "ul")
                                    {
                                        var newIndex = new AnalyzedElement()
                                        {
                                            Element = next,
                                            index = next.index,
                                            depth = next.hierarchyIndexes.Length
                                        };
                                        newIndex.AddFlag(ElementFlags.BadHeaderMenu);
                                        newIndex.isBad = true;
                                        newIndex.isContaminated = true;
                                        futureElements.Add(newIndex);
                                    }
                                }
                            }
                        }
                    }
                    if (words.Length <= 30)
                    {
                        var bad = CountWordsInText(txt, Rules.badKeywords, false) +
                            (CountWordsInText(txt, Rules.badTrailing, false) > 2 ? 1 : 0);
                        //check bad keywords
                        index.UpdateCounter(ElementFlagCounters.badKeywords, bad);

                        //check bad keywords for flagging parent element
                        if (CountWordsInText(txt, Rules.badKeywordsForParentElement, false) > 0)
                        {
                            index.hierarchy.Last().isContaminated = true;
                            RemoveAllChildIndexes(article, indexes, index);
                            continue;
                        }

                        //check percentage of words that are bad
                        if (words.Length > 0 && 100 / words.Length * bad > 30)
                        {
                            index.isBad = true;
                            index.isContaminated = true;
                        }
                    }

                    //check for legal words
                    var legalWords = CountWordsInText(txt, Rules.badLegal);
                    if (legalWords > 0)
                    {
                        index.UpdateCounter(ElementFlagCounters.badLegalWords, legalWords);
                    }
                }
                else
                {
                    //non-text element
                    if (element.tagName == "img")
                    {
                        index.AddFlag(ElementFlags.IsImage);
                    }

                    //get count of text elements as immediate children of current element
                    var childTextElements = 0;
                    foreach (var child in element.Children())
                    {
                        if (child.tagName == "#text")
                        {
                            childTextElements++;
                        }
                    }
                    if (childTextElements > 0)
                    {
                        index.UpdateCounter(ElementFlagCounters.childTextElements, childTextElements);
                    }

                    //check for header
                    if (element.tagName == "header" && element.Parent.tagName == "body")
                    {
                        index.isBad = true;
                        index.isContaminated = true;
                    }

                    //check element for bad class names
                    if (element.className != null && element.className.Count > 0)
                    {
                        var bad = GetWordsInText(string.Join(' ', element.className), Rules.badClasses, false).ToList();
                        if (bad.Count > 0)
                        {
                            bad = bad.Where(badclass =>
                                element.className.Where(classes =>
                                     classes.IndexOf(badclass) >= 0 && !Rules.ignoreClasses.Any(a => classes.IndexOf(a) >= 0)
                                ).Count() > 0).ToList();
                        }
                        index.badClasses = bad.Count;
                        if (index.badClasses > 0)
                        {
                            index.badClassNames = bad;
                            index.isContaminated = true;
                        }
                    }

                    //check element for bad tag names
                    if (Rules.badTags.Contains(element.tagName))
                    {
                        index.AddFlag(ElementFlags.BadTag);
                        index.isBad = true;
                        index.isContaminated = true;
                    }

                    //check element for bad URL
                    if (element.tagName == "a")
                    {
                        if (element.attribute.ContainsKey("href") &&
                            (Rules.badUrls.Where(a => element.attribute["href"].IndexOf(a) >= 0).Count() > 0 ||
                            element.attribute["href"] == article.url))
                        {
                            index.AddFlag(ElementFlags.BadUrl);
                            index.isBad = true;
                        }
                    }
                    if (element.tagName == "img")
                    {
                        if ((element.attribute.ContainsKey("src") &&
                            Rules.badUrls.Where(a => element.attribute["src"].IndexOf(a) >= 0).Count() > 0)
                            )
                        {
                            index.AddFlag(ElementFlags.BadUrl);
                            index.isBad = true;
                        }
                    }
                }
                indexes.Add(index);

            } //check next element

            //Next, analyze groups of elements ////////////////////////////////////////////////////////////////////

            //filter indexes that contain too many legal words
            for (var x = 0; x < indexes.Count; x++)
            {
                var index = indexes[x];
                var children = new List<int>();
                TraverseIndexes(article, index.Element, children, 2);
                var legalwords = indexes.Select(a => children.Contains(a.index) ?
                    (a.Counter(ElementFlagCounters.badLegalWords) > 1 ? a.Counter(ElementFlagCounters.badLegalWords) : 0)
                    : 0).Sum();

                if (legalwords > 5)
                {
                    //too many legal words
                    index.isBad = true;
                    var remove = indexes.Where(a => children.Contains(a.index)).ToList();
                    for (var y = 0; y < remove.Count; y++)
                    {
                        remove[y].isBad = true;
                    }
                }
            }

            //filter best indexes that contain menus
            var menus = indexes.Where(a => a.HasFlag(ElementFlags.MenuItem));
            foreach (var item in menus)
            {
                var parents = item.Element.Hierarchy();
                if (parents.Any(a => a.tagName == "ul" || a.tagName == "ol"))
                {
                    //found parent by ul or ol tag
                    var elem = parents.Last(a => a.tagName == "ul" || a.tagName == "ol");
                    var index = indexes.Where(a => a.index == elem.index).FirstOrDefault();
                    if (index != null)
                    {
                        //make menu container contaminated
                        indexes.Where(a => a.index == elem.index).First().isBad = true;
                        //make all child indexes contaminated
                        var children = new List<int>();
                        TraverseIndexes(article, elem, children);
                        var remove = indexes.Where(a => children.Contains(a.index)).ToList();
                        for (var y = 0; y < remove.Count; y++)
                        {
                            remove[y].isBad = true;
                        }
                    }
                }
                else
                {
                    //try to find menu by traversing backwards through parent elements
                    var i = 4;
                    var elem = article.elements[item.index];
                    while (i-- > 0)
                    {
                        elem = elem.Parent;
                        if (elem != null && elem.tagName == "div")
                        {
                            var index = indexes.Where(a => a.index == elem.index).FirstOrDefault();
                            if (index != null)
                            {
                                if (menus.Where(a => article.elements[a.index].hierarchyIndexes.Where(b => b == index.index).Count() > 0).Count() > 1)
                                {
                                    //found menu container
                                    index.isBad = true;
                                }
                            }
                        }
                    }
                }
                item.isBad = true;
            }

            //filter indexes that contain roles
            for (var x = 0; x < indexes.Count; x++)
            {
                var index = indexes[x];
                var elem = article.elements[index.index];
                if (elem.attribute.ContainsKey("role"))
                {
                    var role = elem.attribute["role"];
                    if (Rules.badRoles.Where(a => a == role).Count() > 0)
                    {
                        //make all child indexes contaminated
                        var children = new List<int>();
                        TraverseIndexes(article, elem, children);
                        var remove = indexes.Where(a => children.Contains(a.index)).ToList();
                        for (var y = 0; y < remove.Count; y++)
                        {
                            remove[y].isBad = true;
                        }
                    }
                }
            }
        }

        public static void GetArticleElements(AnalyzedArticle article, List<AnalyzedElement> indexes)
        {
            //build list of DOM elements that contains the article
            var bodyText = new List<int>();
            int parentId;
            var isFound = false;
            var isEnd = false;
            DomElement elem;
            var checkedIndexes = new List<int>();

            for (var x = indexes.Count - 1; x >= 0; x--)
            {
                //all elements are a part of this parent element
                //get a list of text elements that are a part of the 
                //parent element
                parentId = indexes[x].index;
                isFound = false;
                isEnd = false;
                if (indexes[x].index == 49 || indexes[x].index == 164 || indexes[x].index == 180 || indexes[x].index == 302)
                {

                }
                for (var y = parentId; y < article.elements.Count; y++)
                {
                    elem = article.elements[y];

                    if (elem.hierarchyIndexes.Contains(parentId) || elem.index == parentId)
                    {
                        //check if index was already handled
                        if (checkedIndexes.Contains(elem.index)) { continue; }
                        checkedIndexes.Add(elem.index);

                        //check for bad indexes
                        if (!indexes.Any(a =>
                                (a.index == elem.index || elem.hierarchyIndexes.Contains(a.index))
                                && a.flags.Contains(ElementFlags.ProtectedAnalyzerRule)
                            ) &&
                                indexes.Where(a => (a.isBad == true || a.isContaminated == true) &&
                                (a.index == elem.index || elem.hierarchyIndexes.Contains(a.index))
                            ).Count() > 0
                        ) { break; }

                        //determine which elements to include in the results
                        if (elem.tagName == "#text")
                        {
                            //add text
                            elem.text = WebUtility.HtmlDecode(elem.text);
                            bodyText.Add(elem.index);
                        }
                        else if (elem.tagName == "br")
                        {
                            //add line break
                            bodyText.Add(elem.index);
                        }
                        else if (elem.tagName == "img")
                        {
                            //add image
                            bodyText.Add(elem.index);
                        }
                        else if (elem.tagName == "a")
                        {

                        }
                    }
                    else
                    {
                        //no longer part of parent id
                        isFound = true;
                    }
                    if (isFound == true || isEnd == true) { break; }
                }
            }
            bodyText.Sort();
            article.body = bodyText;

            //get all words for article
            article.rawText = GetArticleText(article);
            article.words = SeparateWordsFromText(article.rawText).ToList();

            //replace all non-alphanumeric characters
            //article.words = words.Select(a => new string(Array.FindAll(a.ToCharArray(), c => char.IsLetterOrDigit(c)))).Where(a => a != "").ToList();
        }

        public static List<string> GetWordsOnly(AnalyzedArticle article)
        {
            return article.words.Select(a => new string(Array.FindAll(a.ToCharArray(), c => char.IsLetterOrDigit(c)))).Where(a => a != "").ToList();
        }

        public static string GetArticleText(AnalyzedArticle article)
        {
            if (article.bodyElements.Count == 0)
            {
                article.bodyElements = article.body.Select(a => article.elements[a]).ToList();
            }
            return string.Join(" ", article.body.Where(a => article.elements[a].text != null).Select(a => article.elements[a].text));
        }

        public static List<string> GetSentences(string text)
        {
            var txt = "";
            var charA = "A".Asc();
            var charZ = "Z".Asc();
            var txt1 = "";
            var txt2 = "";
            char txt3;
            int sentenceStart = 0;
            bool foundSentence = false;
            var sentence = "";
            var sentences = new List<string>();
            var modtext = WebUtility.HtmlDecode(text.Replace("&nbsp;", ""))
                .Replace("... ", "{{p3}}").Replace(".. ", ". ").Replace(".. ", ". ").Replace("{{p3}}", "... ")
                .ReplaceAll("=+={1}=+=", Rules.sentenceSeparators);
            var texts = modtext.Replace("=+==+=", "=+=").Replace("=+==+=", "=+=")
                .Split(new string[] { "=+=" }, StringSplitOptions.RemoveEmptyEntries).Where(p => p.Trim() != "").ToArray();
            for (var x = 0; x < texts.Length; x++)
            {
                foundSentence = false;
                sentence = "";
                txt = texts[x].ToLower().Trim();
                if (txt == "") { continue; }

                //find end of sentence
                if (txt == ".")
                {
                    foundSentence = true;
                    //is period actually used for the end of a sentence 
                    //or is it used for an acronym or abbreviation instead?
                    if (texts.Length > x + 3)
                    {
                        //look ahead for a period
                        txt1 = texts[x + 1].Trim();
                        if (txt1 == "") { txt1 = " "; }
                        if (texts[x + 2].Trim() == ".")
                        {
                            if (txt1.IndexOf(" ") < 0)
                            {
                                //part of an abbreviation or acronym
                                foundSentence = false;
                            }
                            txt2 = texts[x + 3];
                            if (txt2.Length > 3)
                            {
                                //look ahead for website URLs
                                if (Rules.domainSuffixes.Contains(txt2.Substring(0, 3)) == true)
                                {
                                    txt3 = char.Parse(txt2.Substring(3, 1));
                                    if (txt3.CheckChar() == false)
                                    {
                                        //found a website URL, it is not an acronym like I had thought
                                        foundSentence = true;
                                    }
                                }
                            }

                        }
                        else if (Char.Parse(txt1.Substring(0, 1)).CheckChar(true, false, null, true) == true)
                        {
                            //look ahead for a capital letter
                        }
                        //text is a potential sentence part
                        if (x >= 2)
                        {
                            if (texts[x - 1].Trim() == ".")
                            {
                                foundSentence = false;
                            }
                        }
                        if (x < texts.Length - 2)
                        {
                            txt2 = texts[x + 1].Trim();
                            if (txt2.IndexOf("com") == 0)
                            {
                                if (1 == 1)
                                {

                                }
                            }
                            if (txt2.Length > 3)
                            {
                                //look for website URLs
                                if (Rules.domainSuffixes.Contains(txt2.Substring(0, 3)) == true)
                                {
                                    txt3 = Char.Parse(txt2.Substring(3, 1));
                                    if (txt3.CheckChar() == false)
                                    {
                                        //found a website URL
                                        foundSentence = false;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (txt == "!" || txt == "?" || txt == ":")
                {
                    foundSentence = true;
                }


                if (foundSentence == true)
                {
                    //look for quotes
                    if (texts.Length - 1 > x)
                    {
                        txt1 = texts[x + 1].Trim();
                        if (txt1 != "")
                        {
                            txt2 = txt1.Substring(0, 1);
                            if (txt2 == "\"" || txt2 == ",")
                            {
                                foundSentence = false;
                            }
                        }

                    }
                }


                if (foundSentence == true || x == texts.Length - 1)
                {
                    for (int z = sentenceStart; z <= x; z++)
                    {
                        sentence += texts[z];
                    }
                    //check sentence length
                    if (sentence.Length > 1)
                    {
                        txt = sentence.Trim();
                        if (txt.Length > 0)
                        {
                            txt1 = txt.Substring(0, 1);
                            txt2 = txt.Substring(txt.Length - 1, 1);
                            if (Rules.badChars.Contains(txt1) == true)
                            {
                                if (txt.Length > 1)
                                {
                                    txt = txt.Substring(1);
                                }
                                else
                                {
                                    txt = "";
                                }
                            }
                            if (Rules.badChars.Contains(txt2) == true)
                            {
                                if (txt2 != ":")
                                {
                                    txt = txt.Substring(0, txt.Length - 1);
                                }
                            }
                            if (txt != "")
                            {
                                sentences.Add(txt);
                                sentenceStart = x + 1;
                            }
                        }
                    }
                }
            }
            return sentences;
        }

        public static bool IsSentenceSeparator(string character, string[] exceptions = null)
        {
            if (exceptions != null)
            {
                if (exceptions.Contains(character) == true) { return false; }
            }
            return Rules.sentenceSeparators.Contains(character);
        }

        public static void GetImages(AnalyzedArticle article)
        {
            article.images = new List<AnalyzedImage>();
            for (var x = 0; x < article.body.Count; x++)
            {
                var elem = article.elements[article.body[x]];
                if (elem.tagName == "img"
                    && (elem.attribute.ContainsKey("src") || elem.attribute.ContainsKey("srcset")))
                {
                    //first, try to get the highest-resolution image from srcset
                    var url = "";
                    if (elem.attribute.ContainsKey("srcset"))
                    {
                        var src = elem.attribute["srcset"].Split(",").Select(a =>
                        {
                            var parts = a.Trim().Split(" ");
                            var key = 0;
                            if (parts.Length > 1)
                            {
                                int.TryParse(parts[1].ReplaceAll("", new string[] { "w", "h", "x", "y" }), out key);
                            }
                            var kv = new KeyValuePair<int, string>(key, parts[0]);
                            return kv;
                        }).OrderByDescending(a => a.Key).Select(a => a.Value).ToList();
                        url = src.FirstOrDefault();
                    }
                    else if (elem.attribute.ContainsKey("src"))
                    {
                        url = elem.attribute["src"];
                    }

                    var img = new AnalyzedImage()
                    {
                        index = elem.index,
                        url = url
                    };

                    img.filename = img.url.Split("?")[0].Split("#")[0].GetFilename();
                    img.extension = img.filename.GetFileExtension().ToLower();

                    switch (img.extension)
                    {
                        case "jpg":
                        case "jpeg":
                        case "png":
                        case "gif":
                        case "tiff":
                        case "webp":
                        case "bpg":
                        case "flif":
                        case "svg":
                            //only add supported image types
                            article.images.Add(img);
                            break;
                    }

                }
            }
        }

        public static string[] SeparateWordsFromText(string text, string[] exceptions = null)
        {
            if (exceptions != null)
            {

                var ws = Rules.wordSeparators.Where(w => !exceptions.Contains(w)).ToArray();
                return text.ReplaceAll(" {1} ", ws).Split(' ').Where(w => w != "").ToArray();
            }
            return text.ReplaceAll(" {1} ", Rules.wordSeparators).Split(' ').Where(w => w != "").ToArray();
        }

        public static string[] CleanWords(string[] words)
        {
            return words.Where(a => a.OnlyAlphabet()).ToArray();
        }

        public static int CountWordsInText(string text, string[] words, bool matchStartOnly = true)
        {
            return GetWordsInText(text, words, matchStartOnly).Length;
        }

        public static string[] GetWordsInText(string text, string[] words, bool matchStartOnly = true)
        {
            if (matchStartOnly)
            {
                return words.Where(word => text.IndexOf(word) == 0 || ( //first character in text,
                    text.IndexOf(word) > 0 &&                           //or beginning of word
                    text.Substring(text.IndexOf(word) - 1, 1).ToCharArray()[0].CheckChar(true, true) == false //check to see if character before word in text is not alpha-numeric to ensure word is found at beginning of a word in the text
                )).ToArray();
            }
            return words.Where(word => text.Contains(word)).ToArray();
        }

        public static List<string> GetTextFromElement(DomElement elem, int depth = -1)
        {
            var text = new List<string>();
            if (elem.text != null && elem.text != "") { text.Add(elem.text); }
            if (depth == 0) { return text; }
            foreach (var child in elem.Children())
            {
                var list = GetTextFromElement(child, depth > 0 ? depth - 1 : -1);
                if (list.Count > 0) { text.AddRange(list); }
            }
            return text;
        }

        public static void RemoveAllChildIndexes(AnalyzedArticle article, List<AnalyzedElement> indexes, AnalyzedElement element)
        {
            var children = new List<int>();
            TraverseIndexes(article, element.hierarchy.Last().Element, children);
            var remove = indexes.Where(a => children.Contains(a.index)).ToList();
            if (remove.Count > 0)
            {
                var xs = new List<int>();
                foreach (var r in remove.Select(a => a.index))
                {
                    indexes.RemoveAt(indexes.FindIndex(a => a.index == r));
                }
            }
        }

        #endregion

    }
}
